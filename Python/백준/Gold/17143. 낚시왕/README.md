## 끝에 부딪히면 "반사"하며 왕복 이동

### 핵심 아이디어
- 좌표축은 1 ~ L(R or C)에서 거울처럼 방향 전환
- 방향 코드는 두 개
    - pos_code: 아래/오른쪽(+ 방향)
    - neg_code: 위/왼쪽(- 방향)
- 선분의 한쪽 끝에서 다른 쪽 끝까지 갔다가 되돌아오는 한 주기의 길이 
    - period = (L - 1) * 2칸
    -> 이만큼 이동하면 위치와 방향이 처음으로 완전히 되돌아옴

따라서 실제 이동 speed는 `k = speed % period`만큼만 보면 됨

### 단계별 수식 설명
1. 부호 sgn 결정
```
sgn = +1 if dir_code == pos_code else -1
```
2. 앞에 0을 패딩한것을 쉽게 계산하기 위해 임의로 없다고 생각하여 사용 (0-based로 변환)
```
x0 = pos1 - 1 # 현재 위치를 0~L-1 구간에서 설명
span = L - 1 # 최대 인덱스
```

3. 반사 계산
divmod(a,b) == (a//b,  a%b)
```
q, r = divmod(x0 + sgn*k, span)
```
- `x0 + sgn * k`는 반사를 고려하지 않고 직선으로 k칸 이동했다면 어디에 있을까? 를 계산한 가상 좌표
- q : 끝점에 몇 번 반사 했는지 짝/홀 정보
- r : 현재 구간에서 남은 거리(오프셋)


4. 실제 위치/ 방향 결정
- 짝수번 반사 -> 방향 유지
- 홀수번 반사 -> 거울 대칭(방향도 반전)
```
if q % 2 == 0:
    pos0 = r
    sgn2 = sgn
else:
    pos0 = span - r
    sgn2 = -sgn
```

